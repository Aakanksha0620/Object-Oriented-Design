

Intent
------
The Proxy Pattern (structural pattern) provides a surrogate or placeholder for another object to control access to it.Provide a surrogate or placeholder for another object to control access to it. Use an extra level of indirection to support distributed, controlled, or intelligent access. Add a wrapper and delegation to protect the real component from undue complexity.Problem You need to support resource-hungry objects, and you do not want to instantiate such objects unless and until they are actually requested by the client.


Discussion
----------

Design a surrogate, or proxy, object that: instantiates the real object the first time the client makes a request of the proxy, remembers the identity of this real object, and forwards the instigating request to this real object. Then all subsequent requests are simply forwarded directly to the encapsulated real object.



COMMON Application Situations 
-----------------------------

i. A virtual proxy is a placeholder for "expensive to create" objects. The real object is only created when a client first requests/accesses the object.

ii. A remote proxy provides a local representative for an object that resides in a different address space. This is what the "stub" code in RPC and CORBA provides.

iii. A protective proxy controls access to a sensitive master object. The "surrogate" object checks that the caller has the access permissions required prior to forwarding the request.

iv. A smart proxy interposes additional actions when an object is accessed. Typical uses include: 

	Counting the number of references to the real object so that it can be freed 

	automatically when there are no more references (aka smart pointer),

	Loading a persistent object into memory when it's first referenced,

	Checking that the real object is locked before it is accessed to ensure that no other object can change it.




PROXY DESIGN PATTERN
--------------------

The Proxy Pattern is used to create a representative object that controls access to another object, which may be remote, expensive to create or in need of being secured.

One reason for controlling access to an object is to defer the full cost of its creation and initialization until we actually need to use it. Another reason could be to act as a local representative for an object that lives in a different JVM. The Proxy can be very useful in controlling the access to the original object, especially when objects should have different access rights.

In the Proxy Pattern, a client does not directly talk to the original object, it delegates it calls to the proxy object which calls the methods of the original object. The important point is that the client does not know about the proxy, the proxy acts as an original object for the client. But there are many variations to this approach which we will see soon.


Proxy
-----

1a. Maintains a reference that lets the proxy access the real subject. Proxy may refer to a Subject if the RealSubject and Subject interfaces are the same.
1b. Provides an interface identical to Subject’s so that a proxy can be substituted for the real subject.
1c. Controls access to the real subject and may be responsible for creating and deleting it.

Subject
-------
2a. Defines the common interface for RealSubject and Proxy so that a Proxy can be used anywhere a RealSubject is expected.

RealSubject
-----------
3a. Defines the real object that the proxy represents.
There are three main variations to the Proxy Pattern:

A remote proxy provides a local representative for an object in a different address space.
A virtual proxy creates expensive objects on demand.
A protection proxy controls access to the original object. Protection proxies are useful when objects should have different access rights.




Remote Proxy
-----------

There is a Pizza Company, which has its outlets at various locations. The owner of the company gets a daily report by the staff members of the company from various outlets. The current application supported by the Pizza Company is a desktop application, not a web application. So, the owner has to ask his employees to generate the report and send it to him. But now the owner wants to generate and check the report by his own, so that he can generate it whenever he wants without anyone’s help. The owner wants you to develop an application for him.

The problem here is that all applications are running at their respective JVMs and the Report Checker application (which we will design soon) should run in the owner’s local system. The object required to generate the report does not exist in the owner’s system JVM and you cannot directly call on the remote object.

Remote Proxy is used to solve this problem. We know that the report is generated by the users, so there is an object which is required to generate the report. All we need is to contact that object which resides in a remote location in order to get the result that we want. The Remote Proxy acts as a local representative of a remote object. A remote object is an object that lives in the heap of different JVM. You call methods to the local object which forward that calls on to the remote object.

Your client object acts like its making remote method calls. But it is calling methods on a heap-local proxy object that handles all the low-level details of network communication.

Java supports the communication between the two objects residing at two different locations (or two different JVMs) using RMI. RMI is Remote Method Invocation which is used to build the client and service helper objects, right down to creating a client helper object with the same methods as the remote service. Using RMI you don’t have to write any of the networking or I/O code yourself. With your client, you call remote methods just like normal method calls on objects running in the client’s local JVM.

RMI also provides the running infrastructure to make it all work, including a lookup service that the client can use to find and access the remote objects. There is one difference between RMI calls and local method calls. The client helper send the method call across the network, so there is networking and I/O which involved in the RMI calls.






Virtual Proxy
-------------

The Virtual Proxy pattern is a memory saving technique that recommends postponing an object creation until it is needed; it is used when creating an object the is expensive in terms of memory usage or processing involved. In a typical application, different objects make up different parts of the functionality. When an application is started, it may not need all of its objects to be available immediately. In such cases, the Virtual Proxy pattern suggests deferring objects creation until it is needed by the application. The object that is created the first time is referenced in the application and the same instance is reused from that point onwards. The advantage of this approach is a faster application start-up time, as it is not required to created and load all of the application objects.

Suppose there is a Company object in your application and this object contains a list of employees of the company in a ContactList object. There could be thousands of employees in a company. Loading the Company object from the database along with the list of all its employees in the ContactList object could be very time consuming. In some cases you don’t even require the list of the employees, but you are forced to wait until the company and its list of employees loaded into the memory.

One way to save time and memory is to avoid loading of the employee objects until required, and this is done using the Virtual Proxy. This technique is also known as Lazy Loading where you are fetching the data only when it is required.





Protection Proxy
----------------

In general, objects in an application interact with each other to implement the overall application functionality. Most application object are generally accessible to all other objects in the application. At times, it may be necessary to restrict the accessibility of an object only to a limited set of client objects based on their access rights. When a client object tries to access such an object, the client is given access to the services provided by the object only if the client can furnish proper authentication credentials. In such cases, a separate object can be designated with the responsibility of verifying the access privileges of different client objects when they access the actual object. In other words, every client must successfully authenticate with this designated object to get access to the actual object functionality. Such an object with which a client needs to authenticate to get access to the actual object can be referred as an object authenticator which is implemented using the Protection Proxy.

Returning back to the ReportGenerator application that we developed for the pizza company, the owner now requires that only he can generate the daily report. No other employee should be able to do so.

To implement this security feature, we used Protection Proxy which checks if the object which is trying to generate the report is the owner; in this case, the report gets generated, otherwise it is not.




Usages of the Proxy Pattern
---------------------------

Proxy is applicable whenever there is a need for a more versatile or sophisticated reference to an object than a simple pointer. Here are several common situations in which the Proxy pattern is applicable:

A remote proxy provides a local representative for an object in a different address space.
A virtual proxy creates expensive objects on demand.
A protection proxy controls access to the original object. Protection proxies are useful when objects should have different access rights.
7. Other Proxies




Other types of proxies
----------------------

Cache Proxy/Server Proxy: To provide the functionality required to store the results of most frequently used target operations. The proxy object stores these results in some kind of a repository. When a client object requests the same operation, the proxy returns the operation results from the storage area without actually accessing the target object.

Firewall Proxy: The primary use of a firewall proxy is to protect target objects from bad clients. A firewall proxy can also be used to provide the functionality required to prevent clients from accessing harmful targets.

Synchronization Proxy: To provide the required functionality to allow safe concurrent accesses to a target object by different client objects.

Smart Reference Proxy: To provide the functionality to prevent the accidental disposal/deletion of the target object when there are clients currently with references to it. To accomplish this, the proxy keeps a count of the number of references to the target object. The proxy deletes the target object if and when there are no references to it.

Counting Proxy: To provide some kind of audit mechanism before executing a method on the target object.

